import{D as M,E as S,t as k,a as u,i as B}from"./index.js";function D(r,t){let e=t-r;return e===0&&(e=1),n=>n<=r?0:n>=t?1:(n-r)/e}function F(r,t,e){const n=D(t,e);return i=>r(n(i))}/*!
 * chartjs-chart-matrix v1.1.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2021 Jukka Kurkela
 * Released under the MIT license
 */var V="1.1.1";class h extends M{initialize(){this.enableOptionSharing=!0,super.initialize()}update(t){const e=this,n=e._cachedMeta;e.updateElements(n.data,0,n.data.length,t)}updateElements(t,e,n,i){const o=this,s=i==="reset",{xScale:a,yScale:f}=o._cachedMeta,x=o.resolveDataElementOptions(e,i),P=o.getSharedOptions(i,t[e],x);for(let l=e;l<e+n;l++){const p=!s&&o.getParsed(l),C=s?a.getBasePixel():a.getPixelForValue(p.x),R=s?f.getBasePixel():f.getPixelForValue(p.y),g=o.resolveDataElementOptions(l,i),{width:b,height:m,anchorX:v,anchorY:E}=g,O={x:X(v,C,b),y:Y(E,R,m),width:b,height:m,options:g};o.updateElement(t[l],l,O,i)}o.updateSharedOptions(P,i)}draw(){const t=this,e=t.getMeta().data||[];let n,i;for(n=0,i=e.length;n<i;++n)e[n].draw(t._ctx)}}function X(r,t,e){return r==="left"||r==="start"?t:r==="right"||r==="end"?t-e:t-e/2}function Y(r,t,e){return r==="top"||r==="start"?t:r==="bottom"||r==="end"?t-e:t-e/2}h.id="matrix";h.version=V;h.defaults={dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}},anchorX:"center",anchorY:"center"};h.overrides={interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}};function w(r,t){const{x:e,y:n,width:i,height:o}=r.getProps(["x","y","width","height"],t);return{left:e,top:n,right:e+i,bottom:n+o}}function d(r,t,e){return Math.max(Math.min(r,e),t)}function _(r,t,e){const n=r.options.borderWidth;let i,o,s,a;return B(n)?(i=+n.top||0,o=+n.right||0,s=+n.bottom||0,a=+n.left||0):i=o=s=a=+n||0,{t:d(i,0,e),r:d(o,0,t),b:d(s,0,e),l:d(a,0,t)}}function j(r){const t=w(r),e=t.right-t.left,n=t.bottom-t.top,i=_(r,e/2,n/2);return{outer:{x:t.left,y:t.top,w:e,h:n},inner:{x:t.left+i.l,y:t.top+i.t,w:e-i.l-i.r,h:n-i.t-i.b}}}function c(r,t,e,n){const i=t===null,o=e===null,s=!r||i&&o?!1:w(r,n);return s&&(i||t>=s.left&&t<=s.right)&&(o||e>=s.top&&e<=s.bottom)}class y extends S{constructor(t){super(),this.options=void 0,this.width=void 0,this.height=void 0,t&&Object.assign(this,t)}draw(t){const e=this.options,{inner:n,outer:i}=j(this),o=k(e.borderRadius);t.save(),i.w!==n.w||i.h!==n.h?(t.beginPath(),u(t,{x:i.x,y:i.y,w:i.w,h:i.h,radius:o}),u(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:o}),t.fillStyle=e.backgroundColor,t.fill(),t.fillStyle=e.borderColor,t.fill("evenodd")):(t.beginPath(),u(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:o}),t.fillStyle=e.backgroundColor,t.fill()),t.restore()}inRange(t,e,n){return c(this,t,e,n)}inXRange(t,e){return c(this,t,null,e)}inYRange(t,e){return c(this,null,t,e)}getCenterPoint(t){const{x:e,y:n,width:i,height:o}=this.getProps(["x","y","width","height"],t);return{x:e+i/2,y:n+o/2}}tooltipPosition(){return this.getCenterPoint()}getRange(t){return t==="x"?this.width/2:this.height/2}}y.id="matrix";y.defaults={backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:void 0,anchorY:void 0,width:20,height:20};export{h as M,y as a,F as c};
